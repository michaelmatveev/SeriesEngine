using SeriesEngine.Msk1;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace SeriesEngine.ExcelAddIn.Models.DataBlocks
{
    [Serializable]
    public class CollectionDataBlock : SheetDataBlock
    {
        public string NetworkName { get; set; }

        public int NetworkRevision { get; set; }
        public IEnumerable<ObjectMetamodel> SupportedModels { get; set; }
        public int[] ObjectIds { get; set; }

        public bool ShowHeader { get; set; } = true;        
        public object Tag { get; set; }

        public CollectionDataBlock() : base(null, new Period())
        {            
        }

        public CollectionDataBlock(SheetDataBlock parent, Period defaultPeriod) : base(parent, defaultPeriod)
        {
        }

        private static XNamespace ns = "http://www.w3.org/2001/XMLSchema";
        private static XNamespace msdata = "urn:schemas-microsoft-com:xml-msdata";

        public string GetSchema()
        {            
            var schema = new XDocument(
                new XElement(ns +"schema",
                    new XElement(ns + "element", 
                        new XAttribute("name", NetworkTree.RootName), 
                        new XAttribute("nillable", "true"),
                        new XElement(ns + "complexType",
                            new XElement(ns + "sequence", new XAttribute("minOccurs", "0"))))));

            schema.Root.SetAttributeValue(XNamespace.Xmlns + "xs", ns);
            var lastElement = schema.Descendants().Where(d => !d.HasElements).Single();
            var currentPath = $"/{NetworkTree.RootName}";

            // the most nested objects must have an "_Id" column dataset's table, that is not generated by default
            // therefore add extra one level
            //var subFragmentsWithMostNestedStub = DataBlocks.Concat(new[] {
            //    new NodeDataBlock(this)
            //    {
            //        Level = int.MaxValue,
            //        NodeType = NodeType.UniqueName,
            //        RefObject = "Stub"                
            //    }
            //});
            var subFragmentsWithMostNestedStub = DataBlocks;

            foreach (var sfGroup in subFragmentsWithMostNestedStub
                .GroupBy(sf => sf.Level)
                .OrderBy(sfg => sfg.Key))
            {
                var complexType = new XElement(ns + "complexType");
                var sequence = new XElement(ns + "sequence", new XAttribute("minOccurs", "0"));
                complexType.Add(sequence);

                foreach (var sf in sfGroup) 
                {
                    if (!lastElement.Descendants(ns + "element").Any(d => d.Attribute("name").Value == sf.RefObject))
                    {
                        lastElement.Add(
                            new XElement(ns + "element", 
                                new XAttribute("name", sf.RefObject), 
                                new XAttribute("minOccurs", "0"), 
                                new XAttribute("maxOccurs", "unbounded"), 
                                new XAttribute("nillable", "true"), 
                                new XAttribute("form", "unqualified"),
                                complexType));
                        currentPath = $"{currentPath}/{sf.RefObject}";
                    }

                    var nsf = sf as NodeDataBlock;
                    if (nsf != null)
                    {
                        complexType.Add(GetShemaForNode(nsf));
                        sf.XmlPath = $"{currentPath}/@{nsf.NodeType}";
                    }

                    var vsf = sf as VariableDataBlock;
                    if (vsf != null)
                    {
                        sequence.Add(GetShemaForVariable(vsf));
                        if (vsf.VariableMetamodel.IsPeriodic)
                        {
                            sf.XmlPath = $"{currentPath}/{vsf.VariableMetamodel.Name}/Period";
                        }
                        else
                        {
                            sf.XmlPath = $"{currentPath}/{vsf.VariableMetamodel.Name}";
                        }                 
                    }
                }
                lastElement = sequence;                
            }
            return schema.ToString();
        }

        private static XElement GetShemaForNode(NodeDataBlock sf)
        {
            return new XElement(ns + "attribute",
                new XAttribute("name", sf.NodeType.ToString()),
                new XAttribute("type", sf.NodeType == NodeType.Since || sf.NodeType == NodeType.Till ? "xs:dateTime" : "xs:string"),
                new XAttribute("use", sf.NodeType == NodeType.UniqueName ? "required" : "optional"),
                new XAttribute("form", "unqualified"));//,
                //new XAttribute(msdata + "PrimaryKey", sf.NodeType == NodeType.UniqueName ? "true" : "false"));
        }

        private static XElement GetShemaForVariable(VariableDataBlock sf)
        {
            if (sf.VariableMetamodel.IsPeriodic)
            {
                return new XElement(ns + "element",
                    new XAttribute("name", sf.VariableMetamodel.Name),
                    new XElement(ns + "complexType",
                        new XElement(ns + "sequence",
                            new XElement(ns + "element",
                                new XAttribute("maxOccurs", "unbounded"),
                                new XAttribute("name", "Period"),
                                new XElement(ns + "complexType",
                                    new XElement(ns + "simpleContent",
                                        new XElement(ns + "extension",
                                            new XAttribute("base", "xs:string"),
                                            new XElement(ns + "attribute",
                                                new XAttribute("type", "xs:dateTime"),
                                                new XAttribute("use", "required")))))))));
            }
            else
            {
                return new XElement(ns + "element",
                    new XAttribute("name", sf.VariableMetamodel.Name),
                    new XAttribute("type", "xs:string"),
                    new XAttribute("minOccurs", "1"),
                    new XAttribute("maxOccurs", "1"),
                    new XAttribute("nillable", "true"),
                    new XAttribute("form", "unqualified"));
            }
        }

        public string GetXml(NetworkTree network, Period defaultPeriod)
        {
            var xml = network.ConvertToXml(DataBlocks, defaultPeriod);
            return xml.ToString();
        }

        public IList<DataBlock> DataBlocks = new List<DataBlock>();

        public override void Export(int solutionId, BaseDataExporter exproter)
        {
            exproter.ExportDataBlock(solutionId, this);
        }

        public override void Import(int solutionId, BaseDataImporter importer)
        {
            importer.ImportDataBlock(solutionId, this);
        }

    }
}
